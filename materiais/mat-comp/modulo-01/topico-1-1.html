<!DOCTYPE html>
<html lang="pt-br">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>T√≥pico 1.1 ‚Äî Representa√ß√£o Num√©rica</title>
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&family=Fira+Code&family=Dancing+Script:wght@400&display=swap"
        rel="stylesheet">
    <link rel="stylesheet" href="../../../style.css">

    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <style>
        .math-box {
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 12px;
            margin: 20px 0;
            text-align: center;
            overflow-x: auto;
        }

        .concept-box {
            border-left: 4px solid var(--accent);
            background: rgba(46, 204, 113, 0.05);
            padding: 20px;
            margin: 30px 0;
            border-radius: 0 12px 12px 0;
        }

        h2 {
            color: var(--accent);
            margin-top: 50px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding-bottom: 10px;
        }

        h3 {
            color: #fff;
            margin-top: 30px;
        }

        .highlight-text {
            color: var(--accent);
            font-weight: 600;
        }

        /* --- FLASHCARDS INLINE (TREINAMENTO) --- */
        .flashcards-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 25px;
            margin-top: 30px;
        }

        .flip-card {
            background-color: transparent;
            height: 280px;
            perspective: 1000px;
            /* Profundidade do 3D */
            cursor: pointer;
        }

        .flip-card-inner {
            position: relative;
            width: 100%;
            height: 100%;
            transition: transform 0.6s cubic-bezier(0.4, 0, 0.2, 1);
            transform-style: preserve-3d;
        }

        /* Classe acionada pelo JavaScript para girar */
        .flip-card.flipped .flip-card-inner {
            transform: rotateY(180deg);
        }

        .flip-card-front,
        .flip-card-back {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            -webkit-backface-visibility: hidden;
            /* Corre√ß√£o extra para navegadores da Apple */
            border-radius: 12px;
            padding: 25px;
            box-sizing: border-box;
            /* A M√ÅGICA QUE IMPEDE O TRANSBORDAMENTO */
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            /* Alinha o texto no topo para evitar corte nos casos longos */
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
        }

        /* Estilo Din√¢mico: Teoria (Verde) vs Caso Cl√≠nico (Vermelho) */
        .card-teoria .flip-card-front {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-top: 4px solid var(--accent);
        }

        .card-caso .flip-card-front {
            background: rgba(231, 76, 60, 0.05);
            border: 1px solid rgba(231, 76, 60, 0.2);
            border-top: 4px solid #e74c3c;
        }

        .flip-card-back {
            background: #ffffff;
            color: #0b0f14;
            transform: rotateY(180deg);
            border: 2px solid var(--accent);
        }

        .card-caso .flip-card-back {
            border: 2px solid #e74c3c;
        }

        .badge-tipo {
            position: absolute;
            top: 15px;
            right: 15px;
            font-size: 0.65rem;
            padding: 3px 8px;
            border-radius: 12px;
            font-family: 'Fira Code', monospace;
            text-transform: uppercase;
        }
    </style>
</head>

<body class="notion-theme">

    <nav class="top-navbar">
        <a href="index.html" style="color: var(--accent); text-decoration: none; font-weight: bold;">‚Üê VOLTAR AO M√ìDULO
            01</a>
        <span class="jessica-signature">CS_HUB / MAT_COMP / T1.1</span>
    </nav>

    <main class="content-wrapper" style="max-width: 900px; margin: 60px auto;">
        <header class="chapter-header">
            <span class="badge-tech">MATEM√ÅTICA COMPUTACIONAL APLICADA</span>
            <h1 style="font-size: 2.2rem; color: var(--accent);">Representa√ß√£o Num√©rica, Modelo de M√°quina e
                Estabilidade</h1>
            <p>A computa√ß√£o cient√≠fica n√£o opera sobre $ \mathbb{R} $, mas sobre um subconjunto finito $ \mathbb{F}
                \subset \mathbb{R} $ determinado pela arquitetura de m√°quina.</p>
        </header>

        <section class="glass-container-main" style="padding: 40px; border-radius: 24px;">
            <h2>0. Por que uma Matem√°tica da "Imperfei√ß√£o"?</h2>
            <p>Para um matem√°tico puro, a reta real $ \mathbb{R} $ √© cont√≠nua, infinita e densa. Contudo, para um
                computador, a mem√≥ria √© finita e a representa√ß√£o √© bin√°ria. Essa colis√£o entre o <strong>cont√≠nuo
                    ideal</strong> e o <strong>discreto f√≠sico</strong> criou a necessidade de uma nova arquitetura.</p>

            <div class="concept-box">
                <p><strong>A Epistemologia do Erro:</strong></p>
                <div class="math-box">
                    $$\mathbb{F} \subset \mathbb{R} \implies \text{Erro} \neq \text{Falha}$$
                </div>

                <p><strong>Lendo a nota√ß√£o completa:</strong> $\mathbb{F} \subset \mathbb{R}$</p>
                <p>Quando escrevemos $\mathbb{F} \subset \mathbb{R}$, estamos escrevendo a seguinte frase
                    matem√°tica:<br>
                    <em>"O conjunto dos n√∫meros de ponto flutuante do computador ($\mathbb{F}$) √© um subconjunto dos
                        n√∫meros reais ($\mathbb{R}$)."</em>
                </p>

                <p><span class="highlight-text">O que isso significa na pr√°tica para o seu c√≥digo?</span><br>
                    Significa que <strong>todo</strong> n√∫mero que o seu computador consegue processar ($\mathbb{F}$) √©
                    um n√∫mero real. Mas existem infinitos n√∫meros reais ($\mathbb{R}$) que o seu computador n√£o conhece.
                    E √© exatamente porque o computador n√£o conhece a reta inteira que ocorrem os arredondamentos e os
                    erros que estudamos neste m√≥dulo!</p>

                <p>O erro, portanto, n√£o √© um "bug" que deve ser corrigido, mas uma consequ√™ncia das leis da f√≠sica que
                    limitam a mem√≥ria da m√°quina. Dominar a Matem√°tica Computacional √© aprender a caminhar sobre a "reta
                    furada" de $\mathbb{F}$ sem deixar que esses arredondamentos se acumulem e causem falhas
                    catastr√≥ficas.</p>
            </div>

            <h2>1. Sistema de Ponto Flutuante</h2>
            <h3>1.1 Defini√ß√£o Formal</h3>
            <div class="math-box">
                $$ \mathbb{F}(\beta, p, e_{min}, e_{max}) = \{ \pm (1.d_1d_2...d_{p-1})_\beta \times \beta^e \} $$
            </div>
            <ul>
                <li><strong>$ \beta $ (Base):</strong> Determina o sistema de numera√ß√£o (geralmente 2).</li>
                <li><strong>$ p $ (Precis√£o):</strong> Quantidade de d√≠gitos significativos na mantissa. Define o
                    <em>poder de resolu√ß√£o</em>.
                </li>
                <li><strong>$ [e_{min}, e_{max}] $ (Expoente):</strong> Define a escala ou magnitude (Overflow vs
                    Underflow).</li>
            </ul>

            <h3>1.2 Espa√ßamento Absoluto ($ \Delta $)</h3>

            <p>O que √© o Espa√ßamento Absoluto ($\Delta$)? Pense nos n√∫meros inteiros normais: a dist√¢ncia entre o 1 e o
                2 √© de exatamente 1. A dist√¢ncia entre 1000 e 1001 tamb√©m √© 1. O espa√ßamento √© sempre constante.</p>

            <p>Nos n√∫meros de ponto flutuante do computador, <strong>o espa√ßamento n√£o √© constante</strong>. Ele √©
                el√°stico. O $\Delta$ (Delta) √© a dist√¢ncia entre um n√∫mero que o computador consegue armazenar e o
                pr√≥ximo n√∫mero que ele consegue armazenar.</p>

            <p>A f√≥rmula que dita o tamanho desse "salto" √©:</p>
            <div class="math-box">
                $$\Delta = \beta^{e - (p - 1)}$$
            </div>

            <p>No nosso mini-computador did√°tico $\mathbb{F}(2, 4, e)$, se substituirmos as letras, a f√≥rmula vira:</p>
            <div class="math-box">
                $$\Delta = 2^{e - (4 - 1)} = 2^{e - 3}$$
            </div>

            <div class="concept-box" style="text-align: center;">
                <h4>Visualiza√ß√£o do Sistema Did√°tico $ \mathbb{F}(2,4,e) $</h4>
                <p style="font-size: 0.9rem; opacity: 0.8;">Mova o controle deslizante para ver como o espa√ßamento
                    ($\Delta$) cresce junto com o expoente.</p>
                <label>Expoente $ e $: <span id="expValue"
                        style="color:var(--accent); font-weight: bold;">0</span></label>
                <input type="range" min="-5" max="5" value="0" id="expoente"
                    style="width:100%; margin: 15px 0; accent-color: var(--accent);">
                <canvas id="canvasDiscreto" width="800" height="150"
                    style="background: #000; border-radius: 8px; border: 1px solid var(--border); width: 100%;"></canvas>
            </div>

            <div class="concept-box" style="margin-top: 20px;">
                <h4 style="margin-top:0; color: var(--accent);">A M√°gica do Slider (O que acontece na tela)</h4>
                <p>Quando voc√™ arrasta o slider acima, voc√™ est√° mudando o valor do expoente ($e$) e, consequentemente,
                    esticando ou encolhendo o $\Delta$.</p>



                <ul style="line-height: 1.8;">
                    <li><span class="highlight-text">Quando o slider est√° no 0 ($e = 0$):</span> A f√≥rmula fica $\Delta
                        = 2^{0 - 3} = 2^{-3} = 0.125$. Isso significa que, nesta escala perto do zero, o computador
                        conta de $0.125$ em $0.125$. Os "pontinhos verdes" na tela ficam pr√≥ximos. Ele consegue
                        representar perfeitamente o $1.0, 1.125, 1.250...$</li>
                    <li><span class="highlight-text">Se voc√™ arrastar o slider para o 3 ($e = 3$):</span> A f√≥rmula fica
                        $\Delta = 2^{3 - 3} = 2^0 = 1$. Agora, o espa√ßamento aumentou. O computador est√° contando de 1
                        em 1. Ele conhece o 8, o 9, o 10.</li>
                    <li><span class="highlight-text">Se voc√™ arrastar o slider l√° para frente, no 5 ($e = 5$):</span> A
                        f√≥rmula fica $\Delta = 2^{5 - 3} = 2^2 = 4$. <strong>Aqui acontece o desastre num√©rico!</strong>
                        O computador agora conta de 4 em 4. Os pontinhos verdes na tela ficam super distantes. Ele
                        armazena o n√∫mero 32 e o pr√≥ximo n√∫mero que ele consegue armazenar √© o 36.</li>
                </ul>

                <p><strong>A grande quest√£o √©: O que acontece se o seu c√≥digo gerar o n√∫mero 33?</strong> Ele
                    simplesmente n√£o cabe na mem√≥ria desse sistema. O processador vai arredondar o 33 para o 32, criando
                    um <strong>Erro de Arredondamento massivo</strong>.</p>

                <div
                    style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 8px; border-left: 3px solid var(--accent); margin-top: 20px;">
                    <p style="margin: 0; font-family: 'Fira Code', monospace; font-size: 0.9rem;">
                        <strong>Moral da hist√≥ria:</strong> O canvas interativo prova visualmente para o aluno que
                        quanto maior o n√∫mero com o qual voc√™ est√° operando, maior √© o "buraco" (espa√ßamento $\Delta$)
                        entre ele e o pr√≥ximo valor represent√°vel. √â por isso que calcular com valores astron√¥micos
                        destr√≥i a precis√£o das casas decimais na programa√ß√£o!
                    </p>
                </div>
            </div>
            <h2>2. Padr√£o IEEE 754 (Double Precision)</h2>
            <p>At√© 1985, a computa√ß√£o cient√≠fica vivia um verdadeiro caos. Um c√≥digo escrito para um mainframe da IBM
                gerava resultados completamente diferentes se rodasse em um supercomputador da Cray, porque cada
                fabricante inventava sua pr√≥pria regra de como o hardware deveria arredondar n√∫meros decimais.</p>
            <p>Para unificar a ind√∫stria, o Instituto de Engenheiros Eletricistas e Eletr√¥nicos (IEEE) criou o padr√£o
                <strong>754</strong>. Ele √© um "contrato global" gravado direto nos transistores (na Unidade de Ponto
                Flutuante - FPU) que dita exatamente como a mem√≥ria f√≠sica deve fatiar os <strong>64 bits</strong> de
                uma vari√°vel <code>double</code> para tentar representar a reta real infinita ($\mathbb{R}$).
            </p>



            <div class="math-box">
                $$ V = (-1)^s \times (1.m) \times 2^{e - \text{bias}} $$
            </div>

            <ul style="list-style: none; padding: 0;">
                <li style="margin-bottom: 10px;">üü¢ <strong>Sinal (1 bit):</strong> <code>0</code> para positivo,
                    <code>1</code> para negativo ($s$).
                </li>
                <li style="margin-bottom: 10px;">üü° <strong>Expoente (11 bits):</strong> Define a "escala" do n√∫mero (se
                    estamos lidando com a massa de uma gal√°xia ou o tamanho de um √°tomo). Ele usa um "Bias" (vi√©s) de
                    1023 para n√£o precisar gastar um bit extra com o sinal do expoente ($e$).</li>
                <li style="margin-bottom: 10px;">üîµ <strong>Fra√ß√£o / Mantissa (52 bits):</strong> √â aqui que mora a
                    <strong>precis√£o</strong>. S√£o esses bits que guardam os detalhes das casas decimais ($m$).
                </li>
            </ul>

            <div class="concept-box" style="margin-top: 30px;">
                <h4 style="margin-top:0; color: var(--accent);">Por que calcular isso nos ajuda? Os 3 Superpoderes</h4>
                <p>Na An√°lise Num√©rica e na cria√ß√£o de Agentes de IA, n√≥s n√£o calculamos a estrutura do IEEE 754 na m√£o
                    o tempo todo, mas <strong>n√≥s precisamos deduzir seus limites matem√°ticos</strong> para garantir que
                    nossos algoritmos n√£o explodam.</p>

                <h5 style="color: #fff; font-size: 1.1rem; margin-top: 25px;">A. Descobrir a "Precis√£o da M√°quina"
                    ($\varepsilon_{mach}$)</h5>
                <p>Se a mantissa tem 52 bits, existe um limite f√≠sico de quantos n√∫meros podemos espremer entre $1.0$ e
                    o pr√≥ximo n√∫mero represent√°vel. Ao calcularmos $2^{-53}$ (por conta do arredondamento para o par
                    mais pr√≥ximo exigido pelo padr√£o), descobrimos o nosso √âpsilon:</p>
                <div class="math-box">
                    $$ \varepsilon_{mach} = 2^{-53} \approx 1.11 \times 10^{-16} $$
                </div>
                <p><span class="highlight-text">Aplica√ß√£o pr√°tica:</span> Isso prova matematicamente que uma vari√°vel
                    <code>double</code> <strong>s√≥ consegue garantir at√© a 16¬™ casa decimal</strong>. Qualquer d√≠gito a
                    partir da 17¬™ casa √© lixo gerado pelo processador. Se voc√™ estiver calculando a rota de colis√£o de
                    um sat√©lite, voc√™ precisa saber quando parar de confiar na resposta.
                </p>

                <h5 style="color: #fff; font-size: 1.1rem; margin-top: 25px;">B. Prever Overflow e Underflow (Limites do
                    Expoente)</h5>
                <p>Com 11 bits de expoente, o limite superior ($\overline{x}$) de um <code>double</code> no IEEE 754
                    bate na casa de $10^{308}$.</p>
                <p><span class="highlight-text">Aplica√ß√£o pr√°tica:</span> Se voc√™ estiver programando uma Fun√ß√£o de
                    Custo (Loss Function) em Machine Learning com exponenciais, e a conta ultrapassar $10^{308}$, o
                    computador vai cravar a resposta como <code>Infinity</code> (Overflow) e quebrar todo o treinamento.
                    Conhecendo o padr√£o, voc√™ projeta o algoritmo para normalizar os dados antes da conta chegar perto
                    desse teto.</p>

                <h5 style="color: #fff; font-size: 1.1rem; margin-top: 25px;">C. Entender o Bit Impl√≠cito (O "Truque" de
                    Ouro)</h5>
                <p>O padr√£o IEEE 754 for√ßa todo n√∫mero bin√°rio a ser guardado na forma cient√≠fica normalizada (ex:
                    $1.0110 \times 2^e$). Como o primeiro d√≠gito antes do ponto √© <strong>sempre</strong> <code>1</code>
                    (em bin√°rio n√£o existe outro d√≠gito al√©m do 0 e 1, e n√∫meros normalizados n√£o come√ßam com 0), o
                    padr√£o n√£o gasta mem√≥ria salvando esse <code>1</code>. Ele √© oculto (impl√≠cito).</p>
                <p><span class="highlight-text">Aplica√ß√£o pr√°tica:</span> Isso nos d√° 53 bits de precis√£o real usando
                    apenas 52 bits f√≠sicos. √â uma engenharia de software no n√≠vel do sil√≠cio.</p>
            </div>

            <div
                style="background: rgba(0,0,0,0.3); padding: 20px; border-radius: 8px; border-left: 4px solid var(--accent); margin: 30px 0;">
                <h4 style="margin-top:0; color: var(--accent);">Resumo: O Paradigma do Desenvolvedor</h4>
                <p style="margin-bottom: 0;">Estudar e calcular o IEEE 754 tira o programador da posi√ß√£o de "esperar que
                    a linguagem fa√ßa o c√°lculo certo" e o coloca na posi√ß√£o de <strong>arquiteto</strong>. Quando um
                    algoritmo falha por Cancelamento Catastr√≥fico (como veremos no T√≥pico 1.3), voc√™ sabe que n√£o foi um
                    mist√©rio c√≥smico; foi simplesmente a mantissa de 52 bits esgotando sua capacidade de representar os
                    n√∫meros que voc√™ subtraiu.</p>
            </div>

            <h2>3. Modelo Matem√°tico do Erro: O Axioma Fundamental</h2>
            <p>At√© agora, vimos as limita√ß√µes f√≠sicas do hardware. Mas como um matem√°tico escreve uma equa√ß√£o que
                <em>prev√™</em> essa falha f√≠sica do processador? A resposta √© a "certid√£o de nascimento" do erro
                num√©rico: o <strong>Axioma Fundamental do Ponto Flutuante</strong>.
            </p>
            <p>Ele modela matematicamente a imperfei√ß√£o f√≠sica do processador, atuando como a ponte definitiva entre a
                matem√°tica pura e a mem√≥ria RAM da m√°quina.</p>

            <div class="math-box">
                $$ fl(x) = x(1 + \delta), \quad |\delta| \le \varepsilon_{mach} $$
            </div>

            <div class="concept-box">
                <h4 style="margin-top:0; color: var(--accent);">O Dicion√°rio da F√≥rmula (Dissecando os Termos)</h4>
                <ul style="list-style: none; padding: 0; line-height: 1.8;">
                    <li style="margin-bottom: 10px;">‚ö™ <strong>$x$ (O Mundo Ideal):</strong> √â o n√∫mero real, exato e
                        perfeito que voc√™ <em>queria</em> calcular.</li>
                    <li style="margin-bottom: 10px;">üíª <strong>$fl(x)$ (A Realidade):</strong> L√™-se <em>"float de
                            x"</em>. √â o n√∫mero que o processador <em>efetivamente</em> conseguiu espremer e gravar
                        dentro da mantissa de 52 bits.</li>
                    <li style="margin-bottom: 10px;">‚ö†Ô∏è <strong>$\delta$ (O Ped√°gio do Hardware):</strong> L√™-se
                        <em>"delta"</em>. √â uma vari√°vel desconhecida que representa o erro de arredondamento intr√≠nseco
                        daquela opera√ß√£o.
                    </li>
                    <li style="margin-bottom: 10px;">üõ°Ô∏è <strong>$|\delta| \le \varepsilon_{mach}$ (A Garantia de
                            F√°brica):</strong> N√≥s nunca saberemos o valor exato do erro $\delta$, mas o padr√£o IEEE 754
                        nos d√° uma garantia absoluta: o tamanho desse erro <strong>nunca</strong> ultrapassar√° o limite
                        do nosso √âpsilon de M√°quina ($\approx 1.11 \times 10^{-16}$).</li>
                </ul>
            </div>

            <div
                style="background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.1); padding: 30px; border-radius: 12px; margin-top: 30px;">
                <h3
                    style="color: #fff; margin-top: 0; border-bottom: 1px dashed rgba(255,255,255,0.2); padding-bottom: 10px;">
                    A Matem√°tica de Guardanapo: A Prova do "Lixo Num√©rico"</h3>
                <p>Para uma pessoa comum entender a gravidade desse Axioma, basta aplicarmos a regra distributiva (o
                    famoso "chuveirinho" do ensino m√©dio) no lado direito da equa√ß√£o:</p>

                <div class="math-box" style="background: rgba(0,0,0,0.8); border-color: var(--accent);">
                    $$ fl(x) = x + (x \times \delta) $$
                </div>

                <p>Olhe que revela√ß√£o espetacular: o computador n√£o consegue armazenar o seu $x$ puro. Ele armazena o
                    <strong>$x$ original somado a um "lixo" intruso ($x \times \delta$)</strong>!
                </p>
                <p>O grande perigo aqui √© que o tamanho desse lixo √© proporcional ao tamanho do n√∫mero que voc√™ est√°
                    operando. Vamos provar isso com um c√°lculo manual passo a passo:</p>

                <div style="padding-left: 20px; border-left: 3px solid #e74c3c; margin-top: 20px;">
                    <p><strong>Cen√°rio:</strong> Imagine que seu c√≥digo em Java est√° calculando o faturamento anual de
                        uma multinacional, que foi exatamente <strong>10 quatrilh√µes de d√≥lares ($10^{16}$)</strong>.
                    </p>

                    <ol style="line-height: 1.8; margin-bottom: 0;">
                        <li><strong>O Valor Ideal:</strong> $x = 10^{16}$</li>
                        <li><strong>O Limite do Erro:</strong> Vamos assumir o pior cen√°rio do hardware, onde o erro
                            bate no teto do √âpsilon ($\delta = 10^{-16}$).</li>
                        <li><strong>Calculando o "Lixo":</strong> Multiplicamos o valor ideal pelo erro: $10^{16} \times
                            10^{-16}$. Pela regra da matem√°tica, somamos os expoentes ($16 - 16 = 0$). O resultado √©
                            $10^0$, que √© igual a <strong>1</strong>.</li>
                        <li><strong>A Realidade da M√°quina:</strong> $fl(x) = 10^{16} + 1$.</li>
                    </ol>

                    <p style="margin-top: 15px; font-weight: 600; color: #e74c3c;">Conclus√£o do Desastre:</p>
                    <p>O computador gerou "1 d√≥lar" fantasma do absoluto nada! Se estiv√©ssemos operando na casa dos
                        quintilh√µes ($10^{18}$), o erro seria de <strong>100 d√≥lares</strong> ($10^{18} \times 10^{-16}
                        = 10^2$).</p>
                </div>

                <p style="margin-top: 25px;">√â por isso que misturar vari√°veis na casa dos bilh√µes com fra√ß√µes decimais
                    em Machine Learning ou F√≠sica Qu√¢ntica pode destruir a precis√£o do seu sistema inteiro em quest√£o de
                    milissegundos. <strong>O erro num√©rico n√£o √© um bug de l√≥gica, √© uma for√ßa da natureza da
                        m√°quina.</strong></p>
            </div>

            <h2>4. Condicionamento e Estabilidade: O Fator de Caos ($\kappa$)</h2>
            <p>Na se√ß√£o anterior, vimos que o computador sempre insere um "lixo" num√©rico ($\delta$) na entrada dos
                dados. A grande pergunta da An√°lise Num√©rica √©: <strong>O que a sua fun√ß√£o matem√°tica faz com esse
                    lixo?</strong></p>
            <p>Ela absorve e ignora o erro? Ou ela amplifica esse erro at√© destruir a resposta final? Quem mede essa
                sensibilidade √© o <strong>N√∫mero de Condi√ß√£o ($\kappa$)</strong>. O $\kappa$ (Kappa) √© uma propriedade
                do problema matem√°tico, n√£o do computador.</p>

            <div class="math-box">
                $$ \kappa(f,x) = \left| \frac{x f'(x)}{f(x)} \right| $$
            </div>

            <div class="concept-box">
                <h4 style="margin-top:0; color: var(--accent);">Dissecando a F√≥rmula (De onde ela vem?)</h4>
                <p>Para o aluno n√£o decorar cegamente, vamos traduzir os peda√ßos dessa equa√ß√£o:</p>
                <ul style="list-style: none; padding: 0; line-height: 1.8;">
                    <li style="margin-bottom: 10px;">üìà <strong>A Derivada $f'(x)$:</strong> No C√°lculo, a derivada mede
                        a "taxa de varia√ß√£o". Se a derivada √© muito alta, significa que um micro-passo para o lado no
                        eixo X causa um salto gigante no eixo Y. √â a sensibilidade bruta.</li>
                    <li style="margin-bottom: 10px;">‚öñÔ∏è <strong>A Fra√ß√£o $\frac{x}{f(x)}$:</strong> Por que
                        multiplicamos por $x$ e dividimos por $f(x)$? Para transformar o erro absoluto em <strong>erro
                            relativo (porcentagem)</strong>. Dizer que o erro foi de "2" n√£o significa nada (2 gramas √©
                        muito, 2 toneladas √© pouco). Queremos saber a propor√ß√£o do erro.</li>
                </ul>
                <div
                    style="background: rgba(231, 76, 60, 0.1); padding: 15px; border-radius: 8px; border-left: 3px solid #e74c3c; margin-top: 15px;">
                    <strong>O Veredito do $\kappa$:</strong>
                    Se $\kappa \approx 1$, o problema √© <strong>Bem Condicionado</strong> (Seguro).<br>
                    Se $\kappa \gg 1$ (ex: $\kappa = 1000$), o problema √© <strong>Mal Condicionado</strong> (Um erro de
                    $1\%$ na entrada vira um erro de $1000\%$ na sa√≠da. O resultado √© puro lixo).
                </div>
            </div>

            <div
                style="background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.1); padding: 30px; border-radius: 12px; margin-top: 30px;">
                <h3
                    style="color: #fff; margin-top: 0; border-bottom: 1px dashed rgba(255,255,255,0.2); padding-bottom: 10px;">
                    A Matem√°tica de Guardanapo: Calculando o Caos na M√£o</h3>
                <p>Vamos provar como uma fun√ß√£o inofensiva pode esconder um desastre num√©rico. Considere a fun√ß√£o $f(x)
                    = \frac{1}{1 - x}$. Vamos calcular o condicionamento dela quando $x = 0.99$.</p>

                <div class="math-box" style="background: rgba(0,0,0,0.8); border-color: var(--accent);">
                    <strong>Passo 1: Achar a Derivada $f'(x)$</strong><br>
                    $$ f(x) = (1 - x)^{-1} \implies f'(x) = \frac{1}{(1 - x)^2} $$
                </div>

                <div class="math-box" style="background: rgba(0,0,0,0.8); border-color: var(--accent);">
                    <strong>Passo 2: Montar a F√≥rmula do $\kappa$</strong><br>
                    $$ \kappa = \left| \frac{x \cdot \frac{1}{(1-x)^2}}{\frac{1}{1-x}} \right| = \left|
                    \frac{x}{(1-x)^2} \cdot (1-x) \right| = \left| \frac{x}{1-x} \right| $$
                </div>

                <div class="math-box" style="background: rgba(0,0,0,0.8); border-color: #e74c3c;">
                    <strong>Passo 3: Substituir o valor $x = 0.99$</strong><br>
                    $$ \kappa = \left| \frac{0.99}{1 - 0.99} \right| = \frac{0.99}{0.01} = 99 $$
                </div>

                <p style="margin-top: 20px;"><strong>O que esse $\kappa = 99$ significa no mundo real?</strong><br>
                    Significa que a fun√ß√£o atua como um megafone estragado. Se o sensor (ou o √âpsilon de m√°quina)
                    inserir um pequeno erro de $1\%$ ao ler o valor de $x$, a resposta final do seu programa sair√° com
                    <strong>$99\%$ de erro</strong>! O problema √© intrinsecamente doente (Mal Condicionado) perto do
                    n√∫mero 1.
                </p>
            </div>

            <h3 style="margin-top: 40px;">E quando a culpa √© do Algoritmo? (Estabilidade)</h3>
            <p>Se o problema matem√°tico for bem condicionado ($\kappa$ baixo), mas o seu programa continuar gerando lixo
                num√©rico, a√≠ sim <strong>a culpa √© do programador</strong>. Isso significa que o seu <em>algoritmo</em>
                √© <strong>Inst√°vel</strong>.</p>

            <div class="concept-box">
                <h4 style="margin-top:0; color: var(--accent);">A Cura Computacional: O Algoritmo de Kahan</h4>
                <p>Entender o Algoritmo de Kahan √© o que separa um programador que apenas "escreve c√≥digo" de um
                    verdadeiro engenheiro de software que entende a mem√≥ria da m√°quina. Criado por William Kahan (o
                    principal arquiteto do padr√£o IEEE 754), este algoritmo √© a espinha dorsal de sistemas de Machine
                    Learning, Simula√ß√µes F√≠sicas e Big Data.</p>

                <h5 style="color: #fff; margin-top: 25px;">1. O Problema Original (Por que a soma normal falha?)</h5>
                <p>Sempre que voc√™ precisar somar milh√µes de n√∫meros muito pequenos (como atualizar os "pesos" de uma
                    rede neural) a um n√∫mero que j√° est√° muito grande, o Erro de Arredondamento ataca. Imagine que a
                    nossa vari√°vel de soma j√° est√° gigante: <code>s = 10000.0</code>. Agora queremos somar um n√∫mero
                    min√∫sculo: <code>x = 0.00001</code>.</p>
                <p>Como vimos no espa√ßamento $\Delta$, o computador tem um limite de casas decimais. Quando ele tenta
                    somar <code>10000.0 + 0.00001</code>, os √∫ltimos d√≠gitos do <code>0.00001</code> simplesmente "caem
                    para fora" da mantissa de 52 bits. O processador trunca a conta e o resultado continua sendo
                    <code>10000.0</code>. O seu <code>0.00001</code> desapareceu no limbo!
                </p>

                <h5 style="color: #fff; margin-top: 25px;">2. A Aut√≥psia do C√≥digo (O Resgate do Lixo)</h5>
                <p>O que Kahan fez foi criar uma vari√°vel extra, o <code>c</code> (de compensa√ß√£o), que atua como uma
                    "lixeira" matem√°tica. Ela recolhe exatamente os bits que o processador jogou fora, guarda na
                    mem√≥ria, e tenta enfi√°-los de volta na conta na rodada seguinte.</p>

                <pre
                    style="background: #000; padding: 15px; border-radius: 8px; border: 1px solid var(--border); color: #dcdcaa; font-family: 'Fira Code', monospace; overflow-x: auto; margin-bottom: 20px;">
def kahan_sum(n):
    s = 0.0  # Soma principal
    c = 0.0  # Compensador (a lixeira que guarda o erro)
    
    for _ in range(n):
        y = 0.1 - c           # Passo A
        t = s + y             # Passo B
        c = (t - s) - y       # Passo C
        s = t                 # Passo D
        
    return s
</pre>

                <h5 style="color: #fff; margin-top: 25px;">3. Dissecando o Loop (O Segredo Revelado)</h5>
                <ul style="list-style: none; padding: 0; line-height: 1.8;">
                    <li style="margin-bottom: 15px;"><span class="highlight-text">Passo A
                            (<code>y = 0.1 - c</code>):</span> Aqui preparamos o n√∫mero que queremos somar (neste
                        exemplo, <code>0.1</code>). Subtra√≠mos o <code>c</code> (o erro da rodada anterior) para
                        corrigir a rota antes mesmo da soma principal acontecer. Na primeira rodada, <code>c</code> √©
                        zero, ent√£o <code>y = 0.1</code>.</li>

                    <li style="margin-bottom: 15px;"><span class="highlight-text">Passo B
                            (<code>t = s + y</code>):</span> Esta √© a conta onde o "assassinato" acontece. Como o
                        <code>s</code> pode ser um n√∫mero gigante e o <code>y</code> um n√∫mero pequeno, o padr√£o IEEE
                        754 vai cortar os bits finais de <code>y</code>. O <code>t</code> guarda essa soma corrompida e
                        imperfeita.
                    </li>

                    <li style="margin-bottom: 15px;"><span class="highlight-text">Passo C
                            (<code>c = (t - s) - y</code>):</span> Este √© o momento "Aha!" do algoritmo.
                        <ul
                            style="margin-top: 10px; margin-bottom: 10px; padding-left: 20px; border-left: 2px solid rgba(255,255,255,0.2);">
                            <li>Primeiro o computador faz <code>(t - s)</code>. Matematicamente, se
                                <code>t = s + y</code>, ent√£o <code>t - s</code> deveria ser igual a <code>y</code>. Mas
                                lembre-se: o <code>t</code> foi arredondado! Ent√£o <code>(t - s)</code> recupera apenas
                                a parte "sobrevivente" do <code>y</code> que conseguiu entrar na conta.
                            </li>
                            <li>Em seguida, subtra√≠mos o <code>y</code> original e completo:
                                <code>(parte_sobrevivente) - y_original</code>.
                            </li>
                            <li>O resultado dessa conta d√° um n√∫mero negativo que representa <strong>exatamente a poeira
                                    decimal que foi cortada pelo processador</strong>. N√≥s guardamos essa poeira na
                                vari√°vel <code>c</code>.</li>
                        </ul>
                    </li>

                    <li style="margin-bottom: 15px;"><span class="highlight-text">Passo D (<code>s = t</code>):</span>
                        Atualizamos a nossa soma principal com o valor arredondado. Mas agora estamos tranquilos, pois o
                        erro n√£o foi perdido; ele est√° guardado no <code>c</code> pronto para ser compensado no pr√≥ximo
                        "Passo A".</li>
                </ul>
            </div>
            <div
                style="margin-top: 60px; padding: 40px 30px; background: rgba(0, 0, 0, 0.4); border-radius: 16px; border: 1px solid var(--border); box-shadow: 0 10px 30px rgba(0,0,0,0.5);">
                <h3 style="color: var(--accent); text-align: center; margin-top: 0; font-size: 1.8rem;">O Mapa Mental do
                    Erro Num√©rico</h3>
                <p style="text-align: center; opacity: 0.8; margin-bottom: 40px;">O caminho l√≥gico: da f√≠sica do
                    hardware at√© o resgate no c√≥digo.</p>

                <div style="display: flex; align-items: flex-start; margin-bottom: 5px;">
                    <div
                        style="background: var(--accent); color: #000; width: 45px; height: 45px; border-radius: 50%; display: flex; justify-content: center; align-items: center; font-weight: bold; font-size: 1.2rem; flex-shrink: 0; box-shadow: 0 0 15px rgba(46, 204, 113, 0.4);">
                        1</div>
                    <div
                        style="margin-left: 20px; background: rgba(255,255,255,0.03); padding: 20px; border-radius: 12px; flex-grow: 1; border-left: 3px solid var(--accent);">
                        <strong style="color: #fff; font-size: 1.15rem;">A Causa Raiz: A Barreira F√≠sica ($\mathbb{F}
                            \subset \mathbb{R}$)</strong><br>
                        <span
                            style="opacity: 0.8; font-size: 0.95rem; line-height: 1.6; display: block; margin-top: 8px;">A
                            mem√≥ria de 64 bits √© finita. Isso nos for√ßa a abandonar a reta perfeita da matem√°tica e
                            criar uma "reta furada", onde o espa√ßo entre os n√∫meros ($\Delta$) √© el√°stico.</span>
                    </div>
                </div>

                <div
                    style="margin-left: 21px; border-left: 3px dashed rgba(46, 204, 113, 0.3); height: 40px; margin-bottom: 5px;">
                </div>

                <div style="display: flex; align-items: flex-start; margin-bottom: 5px;">
                    <div
                        style="background: var(--accent); color: #000; width: 45px; height: 45px; border-radius: 50%; display: flex; justify-content: center; align-items: center; font-weight: bold; font-size: 1.2rem; flex-shrink: 0; box-shadow: 0 0 15px rgba(46, 204, 113, 0.4);">
                        2</div>
                    <div
                        style="margin-left: 20px; background: rgba(255,255,255,0.03); padding: 20px; border-radius: 12px; flex-grow: 1; border-left: 3px solid var(--accent);">
                        <strong style="color: #fff; font-size: 1.15rem;">A Organiza√ß√£o: O Padr√£o IEEE 754</strong><br>
                        <span
                            style="opacity: 0.8; font-size: 0.95rem; line-height: 1.6; display: block; margin-top: 8px;">Para
                            gerenciar esses buracos, padronizamos a mem√≥ria (Sinal, Expoente e Mantissa). Descobrimos
                            que a mantissa de 52 bits tem um limite m√°ximo de erro: o √âpsilon de M√°quina
                            ($\varepsilon_{mach} \approx 10^{-16}$).</span>
                    </div>
                </div>

                <div
                    style="margin-left: 21px; border-left: 3px dashed rgba(46, 204, 113, 0.3); height: 40px; margin-bottom: 5px;">
                </div>

                <div style="display: flex; align-items: flex-start; margin-bottom: 5px;">
                    <div
                        style="background: var(--accent); color: #000; width: 45px; height: 45px; border-radius: 50%; display: flex; justify-content: center; align-items: center; font-weight: bold; font-size: 1.2rem; flex-shrink: 0; box-shadow: 0 0 15px rgba(46, 204, 113, 0.4);">
                        3</div>
                    <div
                        style="margin-left: 20px; background: rgba(255,255,255,0.03); padding: 20px; border-radius: 12px; flex-grow: 1; border-left: 3px solid var(--accent);">
                        <strong style="color: #fff; font-size: 1.15rem;">A Consequ√™ncia: O Axioma
                            Fundamental</strong><br>
                        <span
                            style="opacity: 0.8; font-size: 0.95rem; line-height: 1.6; display: block; margin-top: 8px;">Traduzimos
                            o √âpsilon para uma f√≥rmula: $fl(x) = x + (x \times \delta)$. O computador sempre adiciona um
                            "lixo num√©rico" que cresce proporcionalmente ao tamanho da vari√°vel operada.</span>
                    </div>
                </div>

                <div
                    style="margin-left: 21px; border-left: 3px dashed rgba(46, 204, 113, 0.3); height: 40px; margin-bottom: 5px;">
                </div>

                <div style="display: flex; align-items: flex-start;">
                    <div
                        style="background: var(--accent); color: #000; width: 45px; height: 45px; border-radius: 50%; display: flex; justify-content: center; align-items: center; font-weight: bold; font-size: 1.2rem; flex-shrink: 0; box-shadow: 0 0 15px rgba(46, 204, 113, 0.4);">
                        4</div>
                    <div
                        style="margin-left: 20px; background: rgba(46, 204, 113, 0.1); padding: 20px; border-radius: 12px; flex-grow: 1; border-left: 3px solid var(--accent);">
                        <strong style="color: #fff; font-size: 1.15rem;">O Diagn√≥stico e a Cura: $\kappa$ e
                            Kahan</strong><br>
                        <span
                            style="opacity: 0.9; font-size: 0.95rem; line-height: 1.6; display: block; margin-top: 8px;">Avaliamos
                            se a culpa da falha √© da Matem√°tica (Mau Condicionamento, medido pelo $\kappa$) ou do
                            Programador (Instabilidade). Para curar algoritmos inst√°veis, usamos t√©cnicas de resgate de
                            bits, como o Algoritmo de Kahan.</span>
                    </div>
                </div>
            </div>
            <div style="margin-top: 80px; padding-top: 40px; border-top: 1px dashed rgba(255,255,255,0.2);">
                <h2 style="margin-top: 0; text-align: center; border: none;">üß† √Årea de Treinamento</h2>
                <p style="text-align: center; opacity: 0.8;">Clique nos cart√µes para virar e conferir as respostas.</p>

                <div id="flashcards-container" class="flashcards-grid"></div>
            </div>


            <footer
                style="margin-top: 80px; text-align: center; border-top: 1px solid var(--border); padding-top: 40px;">
                <p class="signature" style="font-size: 1.8rem; font-family: 'Dancing Script', cursive;">Jessica Fran√ßa
                </p>
            </footer>
    </main>

    <script>
        const canvas = document.getElementById("canvasDiscreto");
        const ctx = canvas.getContext("2d");
        const slider = document.getElementById("expoente");
        const expValue = document.getElementById("expValue");

        function draw(e) {
            // Limpa o quadro a cada movimento do slider
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // L√≥gica Matem√°tica: Define o ponto de partida e o tamanho do buraco
            let baseNum = Math.pow(2, e);          // 1.0 * 2^e
            let delta = Math.pow(2, e - 3);        // O nosso Œî real

            // Linha do Eixo X (Reta cont√≠nua de fundo)
            ctx.beginPath();
            ctx.moveTo(40, 90);
            ctx.lineTo(canvas.width - 40, 90);
            ctx.strokeStyle = "rgba(255, 255, 255, 0.2)";
            ctx.lineWidth = 2;
            ctx.stroke();

            // L√≥gica Visual: O espa√ßamento f√≠sico cresce 30% a cada n√≠vel do slider
            // para criar o efeito visual de "el√°stico" sem estourar a tela instantaneamente
            let basePixelGap = 50;
            let visualGap = basePixelGap * Math.pow(1.3, e);

            ctx.textAlign = "center";

            // Desenhando os pontos e os n√∫meros
            for (let i = 0; i < 15; i++) {
                let x = 40 + (i * visualGap);

                // Se o ponto passar do limite do canvas, para de desenhar
                if (x > canvas.width - 30) break;

                let valorReal = baseNum + (i * delta);

                // Desenha o "Ponto de Ponto Flutuante" (Bolinha Verde)
                ctx.beginPath();
                ctx.arc(x, 90, 6, 0, 2 * Math.PI);
                ctx.fillStyle = "#2ecc71";
                ctx.fill();

                // Escreve o valor num√©rico embaixo da bolinha
                ctx.fillStyle = "rgba(255, 255, 255, 0.8)";
                ctx.font = "12px Inter";
                // Formata o n√∫mero (tira os zeros desnecess√°rios)
                let textoValor = Number.isInteger(valorReal) ? valorReal.toString() : valorReal.toFixed(3);
                ctx.fillText(textoValor, x, 115);
            }

            // Desenha a R√©gua de Medi√ß√£o (Colchete) do Delta no topo
            if (40 + visualGap < canvas.width) {
                let startX = 40;
                let endX = 40 + visualGap;
                let midX = startX + (visualGap / 2);

                ctx.beginPath();
                ctx.moveTo(startX, 75);
                ctx.lineTo(startX, 65);
                ctx.lineTo(endX, 65);
                ctx.lineTo(endX, 75);
                ctx.strokeStyle = "#2ecc71";
                ctx.stroke();

                ctx.fillStyle = "#2ecc71";
                ctx.font = "bold 14px Fira Code";
                ctx.fillText(`Œî = ${delta}`, midX, 55);
            }
        }

        // Escuta os movimentos do Slider em tempo real
        slider.addEventListener("input", function () {
            expValue.textContent = this.value;
            draw(parseInt(this.value));
        });

        // Desenha o estado inicial quando a p√°gina carrega
        setTimeout(() => draw(0), 200);

        // --- L√ìGICA DOS FLASHCARDS ---
        async function carregarFlashcards() {
            try {
                // ATEN√á√ÉO: Ajuste o caminho do arquivo JSON se ele estiver em outra pasta
                const response = await fetch('../../../data/mat-comp/cards-1-1.json');
                const data = await response.json();
                const container = document.getElementById('flashcards-container');

                data.cards.forEach(card => {
                    // Define a classe de cor baseada no tipo do JSON
                    const classeCor = card.tipo === 'caso_clinico' ? 'card-caso' : 'card-teoria';
                    const labelTipo = card.tipo === 'caso_clinico' ? 'üö® Caso Cl√≠nico' : 'üìñ Teoria';
                    const corBadge = card.tipo === 'caso_clinico' ? 'background: rgba(231,76,60,0.2); color: #e74c3c;' : 'background: rgba(46,204,113,0.2); color: var(--accent);';

                    // Cria o HTML do cart√£o
                    const cardHTML = `
                        <div class="flip-card ${classeCor}" onclick="this.classList.toggle('flipped')">
                            <div class="flip-card-inner">
                                <div class="flip-card-front">
                                    <span class="badge-tipo" style="${corBadge}">${labelTipo}</span>
                                    <p style="font-weight: 600; font-size: 0.95rem; margin-top: 20px;">${card.frente.replace(/\n/g, '<br>')}</p>
                                </div>
                                <div class="flip-card-back">
                                    <p style="font-size: 0.9rem; line-height: 1.6;">${card.verso.replace(/\n/g, '<br>')}</p>
                                </div>
                            </div>
                        </div>
                    `;
                    container.innerHTML += cardHTML;
                });

                // Como geramos texto novo que pode ter f√≥rmulas em LaTeX ($...$), 
                // pedimos para o MathJax renderizar a matem√°tica nos cart√µes!
                if (window.MathJax) {
                    MathJax.typesetPromise();
                }

            } catch (error) {
                console.error("Erro ao carregar os flashcards:", error);
                document.getElementById('flashcards-container').innerHTML = "<p style='color: #e74c3c;'>Erro ao carregar os exerc√≠cios. Verifique o caminho do arquivo JSON.</p>";
            }
        }

        // Executa a fun√ß√£o assim que a p√°gina carrega
        carregarFlashcards();
    </script>
</body>

</html>