<!DOCTYPE html>
<html lang="pt-br">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>T√≥pico 1.1 ‚Äî Representa√ß√£o Num√©rica</title>
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&family=Fira+Code&family=Dancing+Script:wght@400&display=swap"
        rel="stylesheet">
    <link rel="stylesheet" href="../../../style.css">

    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <style>
        .math-box {
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 12px;
            margin: 20px 0;
            text-align: center;
            overflow-x: auto;
        }

        .concept-box {
            border-left: 4px solid var(--accent);
            background: rgba(46, 204, 113, 0.05);
            padding: 25px;
            margin: 30px 0;
            border-radius: 0 12px 12px 0;
        }

        h2 {
            color: var(--accent);
            margin-top: 60px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding-bottom: 10px;
        }

        h3 {
            color: #fff;
            margin-top: 40px;
        }

        p {
            margin-bottom: 15px;
        }

        .highlight-text {
            color: var(--accent);
            font-weight: 600;
        }
    </style>
</head>

<body class="notion-theme">

    <nav class="top-navbar">
        <a href="index.html" style="color: var(--accent); text-decoration: none; font-weight: bold;">‚Üê VOLTAR AO M√ìDULO
            01</a>
        <span class="jessica-signature">CS_HUB / MAT_COMP / T1.1</span>
    </nav>

    <main class="content-wrapper" style="max-width: 900px; margin: 60px auto;">
        <header class="chapter-header">
            <span class="badge-tech">MATEM√ÅTICA COMPUTACIONAL APLICADA</span>
            <h1 style="font-size: 2.2rem; color: var(--accent);">Representa√ß√£o Num√©rica, Modelo de M√°quina e
                Estabilidade</h1>
            <p>A computa√ß√£o cient√≠fica n√£o opera sobre $\mathbb{R}$, mas sobre um subconjunto finito $\mathbb{F} \subset
                \mathbb{R}$ determinado pela arquitetura de m√°quina.</p>
        </header>

        <section class="glass-container-main" style="padding: 40px; border-radius: 24px;">

            <h2>0. Por que uma Matem√°tica da "Imperfei√ß√£o"?</h2>
            <p>Para um matem√°tico puro, a reta real $\mathbb{R}$ √© cont√≠nua, infinita e densa. Isso significa que entre
                o n√∫mero 1 e o n√∫mero 2, existe uma infinidade de outros n√∫meros. N√£o importa o qu√£o perto voc√™ d√™ o
                "zoom", a reta n√£o tem buracos.</p>

            <p>Contudo, para um computador, a mem√≥ria √© estritamente finita e a representa√ß√£o √© bin√°ria. Quando
                declaramos uma vari√°vel <code>double</code>, alocamos exatamente 64 bits na mem√≥ria RAM. Com 64 bits, o
                hardware s√≥ consegue representar $2^{64}$ combina√ß√µes √∫nicas. √â fisicamente imposs√≠vel mapear um
                conjunto infinito (os reais) dentro de um espa√ßo finito.</p>

            <p>Portanto, o computador √© for√ßado a escolher um "clube VIP" de n√∫meros que ele vai conseguir representar
                com exatid√£o. Esse subconjunto √© o $\mathbb{F}$ (Floating-point numbers). Todo o resto do universo
                matem√°tico fica de fora, criando "buracos" na nossa reta num√©rica computacional.</p>

            <div class="concept-box">
                <p><strong>A Epistemologia do Erro:</strong></p>
                <div class="math-box">
                    $$\mathbb{F} \subset \mathbb{R} \implies \text{Erro} \neq \text{Falha}$$
                </div>
                <p>Se um c√°lculo gera um n√∫mero real que n√£o pertence a $\mathbb{F}$, o computador √© obrigado a
                    <strong>arredondar</strong> esse valor para o vizinho represent√°vel mais pr√≥ximo. √â aqui que nasce o
                    Erro de Arredondamento.</p>
                <p>O erro n√£o √© um "bug" que deve ser removido, mas uma consequ√™ncia das leis da f√≠sica que limitam a
                    mem√≥ria. Dominar a Matem√°tica Computacional √© aprender a caminhar sobre a "reta furada" de
                    $\mathbb{F}$ sem deixar que esses arredondamentos se acumulem e causem falhas catastr√≥ficas.</p>
            </div>

            <h2>1. Sistema de Ponto Flutuante</h2>
            <p>Como o computador escolhe quem entra no subconjunto $\mathbb{F}$? Ele obedece a uma estrutura formal
                parametrizada pela arquitetura do processador.</p>

            <h3>1.1 Defini√ß√£o Formal</h3>
            <div class="math-box">
                $$\mathbb{F}(\beta, p, e_{min}, e_{max}) = \{ \pm (1.d_1d_2...d_{p-1})_\beta \times \beta^e \}$$
            </div>
            <ul>
                <li><span class="highlight-text">$\beta$ (Base):</span> Determina o sistema de numera√ß√£o (geralmente
                    $\beta=2$ para bin√°rio). Define a "geometria" da distribui√ß√£o na reta.</li>
                <li><span class="highlight-text">$p$ (Precis√£o):</span> Quantidade de d√≠gitos significativos na
                    mantissa. Define o <em>poder de resolu√ß√£o</em>. Quanto maior o $p$, menores s√£o os buracos entre os
                    n√∫meros.</li>
                <li><span class="highlight-text">$[e_{min}, e_{max}]$ (Expoente):</span> Define a escala ou magnitude. O
                    limite superior causa <em>Overflow</em>, e o limite inferior causa <em>Underflow</em>.</li>
            </ul>

            <h3>1.2 Espa√ßamento Absoluto ($\Delta$)</h3>
            <p>Ao contr√°rio dos n√∫meros inteiros, a dist√¢ncia entre dois n√∫meros de ponto flutuante consecutivos n√£o √©
                constante. Perto do zero, os n√∫meros de $\mathbb{F}$ s√£o densos. Conforme vamos para n√∫meros maiores, a
                dist√¢ncia entre eles aumenta.</p>
            <div class="math-box">
                $$\Delta = \beta^{e-(p-1)}$$
            </div>



            <div class="concept-box" style="text-align: center;">
                <h4>Visualiza√ß√£o do Sistema Did√°tico $\mathbb{F}(2,4,e)$</h4>
                <p style="font-size: 0.9rem; opacity: 0.8;">Mova o controle deslizante para ver como o espa√ßamento
                    ($\Delta$) cresce junto com o expoente.</p>
                <label>Expoente $e$: <span id="expValue"
                        style="color:var(--accent); font-weight: bold;">0</span></label>
                <input type="range" min="-5" max="5" value="0" id="expoente"
                    style="width:100%; margin: 15px 0; accent-color: var(--accent);">
                <canvas id="canvasDiscreto" width="800" height="150"
                    style="background: #000; border-radius: 8px; border: 1px solid var(--border); width: 100%;"></canvas>
            </div>

            <h2>2. Padr√£o IEEE 754 (Double Precision)</h2>
            <p>Antes de 1985, cada fabricante de hardware tratava o arredondamento de forma diferente, gerando caos na
                portabilidade de c√≥digos cient√≠ficos. O IEEE 754 padronizou essa arquitetura, mapeando os 64 bits de
                forma estrat√©gica:</p>
            <div class="math-box">
                $$V = (-1)^s \times (1.m) \times 2^{e - \text{bias}}$$
            </div>
            <ul style="list-style: none; padding: 0;">
                <li style="margin-bottom: 10px;">üü¢ <strong>1 bit de sinal ($s$):</strong> Define se √© positivo ou
                    negativo.</li>
                <li style="margin-bottom: 10px;">üü° <strong>11 bits de expoente ($e$):</strong> Controla a escala.
                    Utiliza um vi√©s (Bias = 1023) para lidar com expoentes negativos sem precisar de um bit de sinal
                    extra.</li>
                <li style="margin-bottom: 10px;">üîµ <strong>52 bits de fra√ß√£o/mantissa ($m$):</strong> Onde reside a
                    precis√£o da m√°quina.</li>
            </ul>

            <h3>Deriva√ß√£o da Precis√£o da M√°quina ($\varepsilon_{mach}$)</h3>
            <p>O "√âpsilon de M√°quina" ($\varepsilon_{mach}$) √© o limite m√°ximo de erro relativo que o arredondamento
                pode causar. O menor incremento represent√°vel acima do n√∫mero 1 √© ditado pelos 52 bits da mantissa. Como
                o padr√£o exige arredondamento para o par mais pr√≥ximo, o erro m√°ximo √© a metade desse incremento:</p>
            <div class="math-box">
                $$\varepsilon_{mach} = 2^{-53} \approx 1.11 \times 10^{-16}$$
            </div>

            <h2>3. Modelo Matem√°tico do Erro</h2>
            <p>Com o √âpsilon definido, podemos formular o <strong>Axioma do Ponto Flutuante</strong>. Ele garante que
                qualquer opera√ß√£o real mapeada para a m√°quina sofrer√° uma perturba√ß√£o $\delta$ estritamente controlada:
            </p>
            <div class="math-box">
                $$fl(x) = x(1 + \delta), \quad |\delta| \le \varepsilon_{mach}$$
            </div>
            <p>Isso significa que o valor gravado na mem√≥ria $fl(x)$ √© o valor exato $x$ vezes uma taxa de erro
                impercept√≠vel, mas que matematicamente existe e precisa ser considerada em loops infinitos ou matrizes
                gigantes.</p>

            <h2>4. Condicionamento e Estabilidade</h2>
            <p>O n√∫mero de condi√ß√£o $\kappa$ mede o qu√£o sens√≠vel um problema matem√°tico √© a pequenas perturba√ß√µes na
                entrada (independentemente do computador). Se um problema √© mal condicionado (ex: $\kappa \gg 1$), at√©
                um erro de tamanho $\varepsilon_{mach}$ pode explodir o resultado final.</p>
            <div class="math-box">
                $$\kappa(f,x) = \left| \frac{x f'(x)}{f(x)} \right|$$
            </div>

            <div class="concept-box">
                <h4 style="margin-top:0; color: var(--accent);">Implementa√ß√£o Computacional Pr√°tica</h4>
                <p>O Teorema da Soma nos ensina que, em loops muito grandes, o erro de arredondamento se acumula
                    linearmente. Para somar milhares de pontos flutuantes em Python/Java sem perder precis√£o, usamos
                    algoritmos de <strong>estabilidade backward</strong>, como o famoso <em>Algoritmo de Kahan</em>, que
                    guarda o erro de arredondamento em uma vari√°vel separada (<code>c</code>) e o compensa na itera√ß√£o
                    seguinte:</p>
                <pre
                    style="background: #000; padding: 15px; border-radius: 8px; border: 1px solid var(--border); color: #dcdcaa; font-family: 'Fira Code', monospace; overflow-x: auto;">
def kahan_sum(n):
    s, c = 0.0, 0.0  # s = soma, c = compensa√ß√£o de erro
    for _ in range(n):
        y = 0.1 - c  # Subtrai o erro da itera√ß√£o anterior
        t = s + y    # t √© a soma real (mas perde bits de precis√£o aqui)
        c = (t - s) - y # Recupera matematicamente o que o hardware arredondou!
        s = t
    return s
</pre>
            </div>

        </section>

        <footer style="margin-top: 80px; text-align: center; border-top: 1px solid var(--border); padding-top: 40px;">
            <p class="signature" style="font-size: 1.8rem; font-family: 'Dancing Script', cursive;">Jessica Fran√ßa</p>
        </footer>
    </main>

    <script>
        const canvas = document.getElementById("canvasDiscreto");
        const ctx = canvas.getContext("2d");
        const slider = document.getElementById("expoente");
        const expValue = document.getElementById("expValue");

        function draw(e) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            let nums = [];
            for (let i = 0; i < 8; i++) { nums.push((1 + i / 8) * Math.pow(2, e)); }
            let min = nums[0], max = nums[nums.length - 1], scale = (canvas.width - 100) / (max - min);

            ctx.beginPath(); ctx.moveTo(50, 75); ctx.lineTo(canvas.width - 50, 75);
            ctx.strokeStyle = "#2ecc71"; ctx.stroke();

            nums.forEach(v => {
                let x = 50 + (v - min) * scale;
                ctx.beginPath(); ctx.arc(x, 75, 5, 0, 2 * Math.PI);
                ctx.fillStyle = "#2ecc71"; ctx.fill();
            });
            ctx.fillStyle = "#2ecc71";
            ctx.font = "14px Fira Code";
            ctx.fillText("Œî = 2^(" + (e - 3) + ")", 50, 120);
        }

        slider.addEventListener("input", function () {
            expValue.textContent = this.value;
            draw(parseInt(this.value));
        });

        setTimeout(() => draw(0), 500);
    </script>
</body>

</html>